b7607227
  

with 
    $candidate as candidate, $retailer as retailer
match
    (r:Retailer { id: retailer.id })
with
    candidate, r, retailer
create
    (c:CandidateProduct { id: apoc.text.join([r.id, retailer.productNumber], '_') })
set c.gtin = candidate.gtin
set c.name = candidate.name
set c.image = candidate.image
set c.description = candidate.description
set c.user = candidate.user
set c.weight_unit = candidate.weight.unit
set c.weight_value = candidate.weight.value
set c.weight_label = candidate.weight.label
set c.source = candidate.source
set c.language = candidate.language
set c.translated_name = candidate.translation.name
set c.translated_description = candidate.translation.description
set c.discovered_date = candidate.discoveredDate
set c.created_date = $createdDate
with
    c, r, retailer
merge
    (c)-[rel:HAS_RETAILER]->(r)
set rel.product_number = retailer.productNumber
set rel.group_id = retailer.groupId
set rel.url = retailer.url
set rel.listed = true
set rel.screenshot = retailer.screenshot
set rel.retailer_product_number = apoc.text.join([r.id, retailer.productNumber], '_')
with
    c
optional match
    (u:Universe { name: $universe })
FOREACH
  (ignoreMe in CASE WHEN u is not null THEN [1] ELSE [] END |merge (c)-[:HAS_UNIVERSE]->(u))
  with c
  call apoc.do.when(
    size($tags) > 0,
    \"unwind $tags as tag
    match (t:Tag { name: tag.name, attribute: tag.attribute })<-[:HAS_TAG]-(:Universe { name: $universe })
    with collect(t.name) as tagNames
    match (tg:TagGroup)-[:HAS_TAG]->(t:Tag)
    with tagNames, collect(t.name) as tgTagNames, tg
    where apoc.coll.isEqualCollection(tagNames, tgTagNames)
    with count(tg) as tgs, collect(tg) as taggrps
    call apoc.do.when(
        tgs > 0,
        'return head(taggrps) as tg', '
        create (tg:TagGroup {id: randomUUID()})
        with tg
        unwind $tags as tag
        match (t:Tag {name: tag.name})
        merge (tg)-[:HAS_TAG]->(t)
        return distinct (tg) as tg',
        { taggrps: taggrps, tags: $tags }
    ) yield value
    with value.tg as tg, $c as c
    merge (c)-[:HAS_TAG_GROUP]->(tg)
    return c\",
    \"return $c as c\",
    { tags: $tags, c: c, universe: $universe }
  ) yield value
with
    value.c as c
with
    c
optional match
    (m:Manufacturer { id: $manufacturer })
FOREACH
    (ignoreMe in CASE WHEN m is not null THEN [1] ELSE [] END |merge (c)-[:HAS_MANUFACTURER]->(m))
with
    c
optional match
    (b:Brand { id: $brand })
FOREACH
    (ignoreMe in CASE WHEN b is not null THEN [1] ELSE [] END |merge (c)-[:HAS_BRAND]->(b))
with
    c
optional match
    (sb:SubBrand { id: $subBrand })
FOREACH
    (ignoreMe in CASE WHEN sb is not null THEN [1] ELSE [] END |merge (c)-[:HAS_SUB_BRAND]->(sb))
with
    c
merge
    (cl:GoogleClassification { name: \"/Hobbies \u0026 Leisure\" }) on create set cl.id = randomUUID()
with
    c, cl
merge
    (c)-[crel:HAS_GOOGLE_CLASSIFICATION]->(cl)
set
   crel.confidence = '0.5'
return
    { candidate: properties(c) } as result







  with $candidate as candidate, $retailer as retailer
  match (r:Retailer { id: retailer.id })
  with candidate, r, retailer
  create (c:CandidateProduct { id: apoc.text.join([r.id, retailer.productNumber], '_') })
  set c.gtin = candidate.gtin
  set c.name = candidate.name
  set c.image = candidate.image
  set c.description = candidate.description
  set c.user = candidate.user
  set c.weight_unit = candidate.weight.unit
  set c.weight_value = candidate.weight.value
  set c.weight_label = candidate.weight.label
  set c.source = candidate.source
  set c.language = candidate.language
  set c.translated_name = candidate.translation.name
  set c.translated_description = candidate.translation.description
  set c.discovered_date = candidate.discoveredDate
  set c.created_date = $createdDate

  with c, r, retailer
  merge (c)-[rel:HAS_RETAILER]->(r)
  set rel.product_number = retailer.productNumber
  set rel.group_id = retailer.groupId
  set rel.url = retailer.url
  set rel.listed = true
  set rel.screenshot = retailer.screenshot
  set rel.retailer_product_number = apoc.text.join([r.id, retailer.productNumber], '_')

  with c
  optional match(u:Universe { name: $universe })
  FOREACH (ignoreMe in CASE WHEN u is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_UNIVERSE]->(u)
  )

  with c
  call apoc.do.when(size($tags) > 0, \"
    unwind $tags as tag
    match (t:Tag { name: tag.name, attribute: tag.attribute })<-[:HAS_TAG]-(:Universe { name: $universe })
    with collect(t.name) as tagNames
    match (tg:TagGroup)-[:HAS_TAG]->(t:Tag)
    with tagNames, collect(t.name) as tgTagNames, tg
    where apoc.coll.isEqualCollection(tagNames, tgTagNames)
    with count(tg) as tgs, collect(tg) as taggrps
    call apoc.do.when(tgs > 0, 'return head(taggrps) as tg', '
        create (tg:TagGroup {id: randomUUID()})
        with tg
        unwind $tags as tag
        match (t:Tag {name: tag.name})
        merge (tg)-[:HAS_TAG]->(t)
        return distinct (tg) as tg
    ', { taggrps: taggrps, tags: $tags }) yield value
    with value.tg as tg, $c as c
    merge (c)-[:HAS_TAG_GROUP]->(tg)
    return c
  \", \"return $c as c\", { tags: $tags, c: c, universe: $universe }) yield value
  with value.c as c

  with c
  optional match(m:Manufacturer { id: $manufacturer })
  FOREACH (ignoreMe in CASE WHEN m is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_MANUFACTURER]->(m)
  )

  with c
  optional match(b:Brand { id: $brand })
  FOREACH (ignoreMe in CASE WHEN b is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_BRAND]->(b)
  )

  with c
  optional match(sb:SubBrand { id: $subBrand })
  FOREACH (ignoreMe in CASE WHEN sb is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_SUB_BRAND]->(sb)
  )

  
      with c
      merge(cl:GoogleClassification { name: \"/Food \u0026 Drink\" })
        on create
          set cl.id = randomUUID()
      with c, cl
      merge(c)-[crel:HAS_GOOGLE_CLASSIFICATION]->(cl)
      set crel.confidence = '0.7799999713897705'
    
  return { candidate: properties(c) } as result
", "
  with $candidate as candidate, $retailer as retailer
  match (r:Retailer { id: retailer.id })
  with candidate, r, retailer
  create (c:CandidateProduct { id: apoc.text.join([r.id, retailer.productNumber], '_') })
  set c.gtin = candidate.gtin
  set c.name = candidate.name
  set c.image = candidate.image
  set c.description = candidate.description
  set c.user = candidate.user
  set c.weight_unit = candidate.weight.unit
  set c.weight_value = candidate.weight.value
  set c.weight_label = candidate.weight.label
  set c.source = candidate.source
  set c.language = candidate.language
  set c.translated_name = candidate.translation.name
  set c.translated_description = candidate.translation.description
  set c.discovered_date = candidate.discoveredDate
  set c.created_date = $createdDate

  with c, r, retailer
  merge (c)-[rel:HAS_RETAILER]->(r)
  set rel.product_number = retailer.productNumber
  set rel.group_id = retailer.groupId
  set rel.url = retailer.url
  set rel.listed = true
  set rel.screenshot = retailer.screenshot
  set rel.retailer_product_number = apoc.text.join([r.id, retailer.productNumber], '_')

  with c
  optional match(u:Universe { name: $universe })
  FOREACH (ignoreMe in CASE WHEN u is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_UNIVERSE]->(u)
  )

  with c
  call apoc.do.when(size($tags) > 0, \"
    unwind $tags as tag
    match (t:Tag { name: tag.name, attribute: tag.attribute })<-[:HAS_TAG]-(:Universe { name: $universe })
    with collect(t.name) as tagNames
    match (tg:TagGroup)-[:HAS_TAG]->(t:Tag)
    with tagNames, collect(t.name) as tgTagNames, tg
    where apoc.coll.isEqualCollection(tagNames, tgTagNames)
    with count(tg) as tgs, collect(tg) as taggrps
    call apoc.do.when(tgs > 0, 'return head(taggrps) as tg', '
        create (tg:TagGroup {id: randomUUID()})
        with tg
        unwind $tags as tag
        match (t:Tag {name: tag.name})
        merge (tg)-[:HAS_TAG]->(t)
        return distinct (tg) as tg
    ', { taggrps: taggrps, tags: $tags }) yield value
    with value.tg as tg, $c as c
    merge (c)-[:HAS_TAG_GROUP]->(tg)
    return c
  \", \"return $c as c\", { tags: $tags, c: c, universe: $universe }) yield value
  with value.c as c

  with c
  optional match(m:Manufacturer { id: $manufacturer })
  FOREACH (ignoreMe in CASE WHEN m is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_MANUFACTURER]->(m)
  )

  with c
  optional match(b:Brand { id: $brand })
  FOREACH (ignoreMe in CASE WHEN b is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_BRAND]->(b)
  )

  with c
  optional match(sb:SubBrand { id: $subBrand })
  FOREACH (ignoreMe in CASE WHEN sb is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_SUB_BRAND]->(sb)
  )

  
      with c
      merge(cl:GoogleClassification { name: \"/Food \u0026 Drink/Food/Candy \u0026 Sweets\" })
        on create
          set cl.id = randomUUID()
      with c, cl
      merge(c)-[crel:HAS_GOOGLE_CLASSIFICATION]->(cl)
      set crel.confidence = '0.9800000190734863'
    
  return { candidate: properties(c) } as result
", "
  with $candidate as candidate, $retailer as retailer
  match (r:Retailer { id: retailer.id })
  with candidate, r, retailer
  create (c:CandidateProduct { id: apoc.text.join([r.id, retailer.productNumber], '_') })
  set c.gtin = candidate.gtin
  set c.name = candidate.name
  set c.image = candidate.image
  set c.description = candidate.description
  set c.user = candidate.user
  set c.weight_unit = candidate.weight.unit
  set c.weight_value = candidate.weight.value
  set c.weight_label = candidate.weight.label
  set c.source = candidate.source
  set c.language = candidate.language
  set c.translated_name = candidate.translation.name
  set c.translated_description = candidate.translation.description
  set c.discovered_date = candidate.discoveredDate
  set c.created_date = $createdDate

  with c, r, retailer
  merge (c)-[rel:HAS_RETAILER]->(r)
  set rel.product_number = retailer.productNumber
  set rel.group_id = retailer.groupId
  set rel.url = retailer.url
  set rel.listed = true
  set rel.screenshot = retailer.screenshot
  set rel.retailer_product_number = apoc.text.join([r.id, retailer.productNumber], '_')

  with c
  optional match(u:Universe { name: $universe })
  FOREACH (ignoreMe in CASE WHEN u is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_UNIVERSE]->(u)
  )

  with c
  call apoc.do.when(size($tags) > 0, \"
    unwind $tags as tag
    match (t:Tag { name: tag.name, attribute: tag.attribute })<-[:HAS_TAG]-(:Universe { name: $universe })
    with collect(t.name) as tagNames
    match (tg:TagGroup)-[:HAS_TAG]->(t:Tag)
    with tagNames, collect(t.name) as tgTagNames, tg
    where apoc.coll.isEqualCollection(tagNames, tgTagNames)
    with count(tg) as tgs, collect(tg) as taggrps
    call apoc.do.when(tgs > 0, 'return head(taggrps) as tg', '
        create (tg:TagGroup {id: randomUUID()})
        with tg
        unwind $tags as tag
        match (t:Tag {name: tag.name})
        merge (tg)-[:HAS_TAG]->(t)
        return distinct (tg) as tg
    ', { taggrps: taggrps, tags: $tags }) yield value
    with value.tg as tg, $c as c
    merge (c)-[:HAS_TAG_GROUP]->(tg)
    return c
  \", \"return $c as c\", { tags: $tags, c: c, universe: $universe }) yield value
  with value.c as c

  with c
  optional match(m:Manufacturer { id: $manufacturer })
  FOREACH (ignoreMe in CASE WHEN m is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_MANUFACTURER]->(m)
  )

  with c
  optional match(b:Brand { id: $brand })
  FOREACH (ignoreMe in CASE WHEN b is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_BRAND]->(b)
  )

  with c
  optional match(sb:SubBrand { id: $subBrand })
  FOREACH (ignoreMe in CASE WHEN sb is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_SUB_BRAND]->(sb)
  )

  
      with c
      merge(cl:GoogleClassification { name: \"/Food \u0026 Drink/Food/Candy \u0026 Sweets\" })
        on create
          set cl.id = randomUUID()
      with c, cl
      merge(c)-[crel:HAS_GOOGLE_CLASSIFICATION]->(cl)
      set crel.confidence = '0.9599999785423279'
     
      with c
      merge(cl:GoogleClassification { name: \"/Hobbies \u0026 Leisure/Special Occasions\" })
        on create
          set cl.id = randomUUID()
      with c, cl
      merge(c)-[crel:HAS_GOOGLE_CLASSIFICATION]->(cl)
      set crel.confidence = '0.5299999713897705'
     
      with c
      merge(cl:GoogleClassification { name: \"/Shopping/Gifts \u0026 Special Event Items\" })
        on create
          set cl.id = randomUUID()
      with c, cl
      merge(c)-[crel:HAS_GOOGLE_CLASSIFICATION]->(cl)
      set crel.confidence = '0.5099999904632568'
    
  return { candidate: properties(c) } as result
", "
  with $candidate as candidate, $retailer as retailer
  match (r:Retailer { id: retailer.id })
  with candidate, r, retailer
  create (c:CandidateProduct { id: apoc.text.join([r.id, retailer.productNumber], '_') })
  set c.gtin = candidate.gtin
  set c.name = candidate.name
  set c.image = candidate.image
  set c.description = candidate.description
  set c.user = candidate.user
  set c.weight_unit = candidate.weight.unit
  set c.weight_value = candidate.weight.value
  set c.weight_label = candidate.weight.label
  set c.source = candidate.source
  set c.language = candidate.language
  set c.translated_name = candidate.translation.name
  set c.translated_description = candidate.translation.description
  set c.discovered_date = candidate.discoveredDate
  set c.created_date = $createdDate

  with c, r, retailer
  merge (c)-[rel:HAS_RETAILER]->(r)
  set rel.product_number = retailer.productNumber
  set rel.group_id = retailer.groupId
  set rel.url = retailer.url
  set rel.listed = true
  set rel.screenshot = retailer.screenshot
  set rel.retailer_product_number = apoc.text.join([r.id, retailer.productNumber], '_')

  with c
  optional match(u:Universe { name: $universe })
  FOREACH (ignoreMe in CASE WHEN u is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_UNIVERSE]->(u)
  )

  with c
  call apoc.do.when(size($tags) > 0, \"
    unwind $tags as tag
    match (t:Tag { name: tag.name, attribute: tag.attribute })<-[:HAS_TAG]-(:Universe { name: $universe })
    with collect(t.name) as tagNames
    match (tg:TagGroup)-[:HAS_TAG]->(t:Tag)
    with tagNames, collect(t.name) as tgTagNames, tg
    where apoc.coll.isEqualCollection(tagNames, tgTagNames)
    with count(tg) as tgs, collect(tg) as taggrps
    call apoc.do.when(tgs > 0, 'return head(taggrps) as tg', '
        create (tg:TagGroup {id: randomUUID()})
        with tg
        unwind $tags as tag
        match (t:Tag {name: tag.name})
        merge (tg)-[:HAS_TAG]->(t)
        return distinct (tg) as tg
    ', { taggrps: taggrps, tags: $tags }) yield value
    with value.tg as tg, $c as c
    merge (c)-[:HAS_TAG_GROUP]->(tg)
    return c
  \", \"return $c as c\", { tags: $tags, c: c, universe: $universe }) yield value
  with value.c as c

  with c
  optional match(m:Manufacturer { id: $manufacturer })
  FOREACH (ignoreMe in CASE WHEN m is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_MANUFACTURER]->(m)
  )

  with c
  optional match(b:Brand { id: $brand })
  FOREACH (ignoreMe in CASE WHEN b is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_BRAND]->(b)
  )

  with c
  optional match(sb:SubBrand { id: $subBrand })
  FOREACH (ignoreMe in CASE WHEN sb is not null THEN [1] ELSE [] END |
    merge (c)-[:HAS_SUB_BRAND]->(sb)
  )

  
      with c
      merge(cl:GoogleClassification { name: \"/People \u0026 Society/Religion \u0026 Belief\" })
        on create
          set cl.id = randomUUID()
      with c, cl
      merge(c)-[crel:HAS_GOOGLE_CLASSIFICATION]->(cl)
      set crel.confidence = '0.9200000166893005'
     
      with c
      merge(cl:GoogleClassification { name: \"/Hobbies \u0026 Leisure/Special Occasions/Holidays \u0026 Seasonal Events\" })
        on create
          set cl.id = randomUUID()
      with c, cl
      merge(c)-[crel:HAS_GOOGLE_CLASSIFICATION]->(cl)
      set crel.confidence = '0.8500000238418579'
     
      with c
      merge(cl:GoogleClassification { name: \"/Shopping/Gifts \u0026 Special Event Items\" })
        on create
          set cl.id = randomUUID()
      with c, cl
      merge(c)-[crel:HAS_GOOGLE_CLASSIFICATION]->(cl)
      set crel.confidence = '0.6000000238418579'
     
      with c
      merge(cl:GoogleClassification { name: \"/Food \u0026 Drink\" })
        on create
          set cl.id = randomUUID()
      with c, cl
      merge(c)-[crel:HAS_GOOGLE_CLASSIFICATION]->(cl)
      set crel.confidence = '0.5'
    
  return { candidate: properties(c) } as result
"]
}, {